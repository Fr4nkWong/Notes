---
title: JS正则表达式小记
date: 2017-04-20
category:
- javascript
---
## 前言

## 符号规则
JS中有三种匹配模式：g(全文匹配), m(多行匹配), i(忽略大小写)。
- **关于括号**
 - () 的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。Eg: (\d+) 表示连续数字的字符串。
 - [] 的作用是定义匹配的字符返回。Eg: [a-zA-Z0-9] 表示文本要匹配英文字符和数字。
 - {} 的作用是表示匹配的长度。Eg: +\d{3} 表示匹配3个数字。
- **关于匹配位置、方向**
 - **^ 出现在[]中具有取反的作用; 出现在其他地方则表示匹配字符串开头。**Eg：(^a) 匹配以字母a开头的字符串。[^abc] 匹配的字符串不包括abc。
 - $ 匹配字符串的结尾。Eg：(b$) 匹配以字母b结尾的字符串。
- **关于匹配字符简写**
 - \d 匹配一个非负整数，等价于[0-9]
 - \s 匹配一个空白字符
 - \w 匹配一个英文字母或数字，等价于[0-9a-zA-Z]
 - . 匹配除换行符以外的任意字符，等价于[^\n]
- **关于匹配次数**
 - \* 表示匹配前面元素0次或多次。Eg: (\s*) 匹配0个或多个空格。
 - \+ 表示匹配前面元素1次或多次。Eg: (\d+) 匹配由至少1个整数组成的字符串。
 - ? 表示匹配前面元素0次或1次，等价于{0,1}。Eg: (\w?) 匹配最多由一个字母或数字组成的字符串。
- **$1-$9和\1-\9**
 - $1-$9 存着正则表达式中最近9个正则表达式提取的结果，结果按子匹配的出现顺序依次排列。
 - \1-\9 表示向后引用，指在正则表达式中从左往右数，第1至9个()中的内容。\0 表示整个表达式。
 -  **$n只能用在表达式之外的地方，\n只能用在表达式中。**

``` bash
"2017-01-10".replace(/(\d+)-(\d+)-(\d+)/,"$1年$2月$3日"); // 2017年1月10日
let reg = /\d{4}(\-|\/|.)\d{1,2}\1\d{1,2}/
reg.test("2017-01-10"); // true
reg.test("2017-01.10"); // false
```
## 基本方法
- JS正则表达式的创建有两种方式：new RegExp()，字面量。
``` bash
let regObj = new RegExp("(^\\s+)","g"); // 对象创建，注意双斜杠转义
let regStr = /(^\\s+)/g; // 字面量
```
- JS正则表达式两种匹配方法：reg.exec(regStr), regStr.match(reg)。
``` bash
"123a456b789".match(/\d+/g); // ["123","456","789"]
let reg = /\d+/g;
reg.exec("123a456b789"); // ["123","456","789"]
```
- test()和replace()
string.replace([RegExp|String],[String|Callback(result,[$1...$9],offset,source)]) 标准的解释格式~
如果第1个参数是RegExp, JS会先提取RegExp匹配出的结果，然后用第2个参数在调用字符串中逐一替换匹配出的结果。
如果第2个参数是回调函数，每匹配到一个结果就回调一次，每次回调都会传递以上格式参数。
``` bash
/\d+/.test("123"); // true
/\d+//test("Abc"); // false

//实现HTML编码，将< / > " & ` 等字符进行转义，避免XSS攻击 
function htmlEncode(str) {
    //匹配< / > " & `
    return str.replace(/[<>"&\/`]/g, function(rs) {
        switch (rs) {
            case "<":
                return "<";
            case ">":
                return ">";
            case "&":
                return "&";
            case "\"":
                return """;
            case "/": 
                return "/"
            case "`":
                return "'"
        }
    });
}
```
## 小结
在我看来，正则表达式充满了魔法，它的魅力远远超乎想象甚至是对于它最初的定义。用的好能让我们更效率更精确地对数据进行分析，用的不好会使你的数据充满危险。正是因为这样正则表达式也是hack的基础，要想geek起来必须得熟练使用它才行 :-)